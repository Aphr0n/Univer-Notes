Проектування процесора базується на проектуванні його компонентів та системи взаємозв'язків, враховуючи: 
1. потік даних/операндів між функціональними блоками процесора; 
2. потік керування.
# Проектування
1. Зчитування інструкції
	![[Pasted image 20260110032245.png]]
2. Зчитування операндів з регістрового файлу (RF)
	![[Pasted image 20260110032338.png]]
3. Підтримка роботи з константами
	![[Pasted image 20260110032407.png]]
4. Обчислення адреси комірки пам'яті
	   ![[Pasted image 20260110032435.png]]
5. Зчитування даних з пам'яті та запис їх у реєстровий файл
	![[Pasted image 20260110032504.png]]
6. Визначення адреси наступної інструкції
	![[Pasted image 20260110032533.png]]
7. Запис даних, що зберігаються в регістрі rt, у пам'ять даних
	![[Pasted image 20260110032611.png]]
8. Інструкції типи R
	- Читання з регістрів rs та rt
	- Запис ALUResult до набору регістрів
	- Запис до регістра rd (замість регістра rt)
9. beq
	- Оцінка відношення "дорівнює" для вмісту регістрів rs та rt
	- Обчислення адреси переходу: BTA = (знаково розширений негайний << 2) + (PC+4)
# Управління
![[Pasted image 20260110032854.png]]
# Арифметично-логічна одиниця
![[Pasted image 20260110032936.png]]
![[Pasted image 20260110032951.png]]
## Декодер арифметично-логічної одиниці
![[Pasted image 20260110033023.png]]
# Головний декодер керуючої частини процесора
![[Pasted image 20260110033119.png]]

| Instruction | $Op_{5:0}$ | RegWrite | RegDst | AluSrc | Branch | MemWrite | MemtoReg | $ALUOP_{1:0}$ | Jump |
| ----------- | ---------- | -------- | ------ | ------ | ------ | -------- | -------- | ------------- | ---- |
| R-Type      | 000000     | 1        | 1      | 0      | 0      | 0        | 0        | 10            | 0    |
| lw          | 100011     | 1        | 0      | 1      | 0      | 0        | 1        | 00            | 0    |
| sw          | 101011     | 0        | X      | 1      | 0      | 1        | X        | 00            | 0    |
| beq         | 000100     | 0        | X      | 0      | 1      | 0        | X        | 01            | 0    |
| j           | 000100     | 0        | X      | X      | X      | 0        | X        | XX            | 1    |


# Iнструкція or
![[Pasted image 20260110033155.png]]
# Підтримка інструкцій addi
![[Pasted image 20260110033254.png]]
Не вимагає модифікації потоку даних/маршрутизації операндів
# Блок керування: addi
![[Pasted image 20260110033340.png]]

# Розширення функціональності для інструкції j
![[Pasted image 20260110033442.png]]
# Характеристики
Час відгуку = (#інструкцій)(тактів/інструкція)(секунди/такт) = # інструкцій x CPI x TC
## Продуктивність процесора за один такт
![[Pasted image 20260110034108.png]]
$T_C$ обмежений найдовшим маршрутом (dw): 
	$T_c = t_{pcq_PC} + t_{mem} + max(t_{RFread}, t_{sext} + t_{mux}) + t_{ALU} + t_{mem} t_{mux} + t_{RFsetup}$ 
В більшості випадків:
- пам'ять, АЛП, набір регістрів
- $T_c = t_{pcq_PC} + 2(t_{mem}) + t_{RFread} + t_{mux} + t_{ALU} + t_{RFsetup}$ 
### Приклад
![[Pasted image 20260110034522.png]]
$T_c = t_{pcq_PC} + 2(t_{mem}) + t_{RFread} + t_{mux} + t_{ALU} + t_{RFsetup} = [30 + 2(250) + 150 25 + 200 + 20] = 925 ps * 10^{-12} = 0.95$ 