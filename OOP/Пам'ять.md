# Типи пам'яті
## Статична пам'ять
В статичній пам'яті сутність може бути приєднана щонайбільше до одного об'єкта середовища виконання протягом усього виконання програмного забезпечення. Виділити місце для всіх об'єктів (і приєднати їх до відповідних сутностей) один раз і назавжди, під час завантаження програми або на початку виконання.
**Проблеми:**
- Рекурсія дозволена 
- Неможливо використовувати динамічні структури даних
**Перерозподіл пам'яті:**
- 0 проблем в перерозподілі 
## Стек
В стеку сутність може під час виконання послідовно приєднатися до кількох об'єктів, а механізми виконання розподіляють та звільняють ці об'єкти в порядку "останнім прийшов, першим вийшов". Коли об'єкт звільняється, відповідна сутність знову приєднується до об'єкта, до якого вона була раніше приєднана, якщо такі є.
**Проблеми:**
- Неможливо використовувати динамічні структури даних
**Перерозподіл пам'яті:**
- За допомогою блокової структурованості розподіл об'єктів відбувається одночасно для всіх сутностей, оголошених у даному блоці, що дозволяє використовувати один стек для всієї програми 
## Куча
В кучі сутність може послідовно приєднуватися до будь-якої кількості об'єктів; схема створення об'єктів зазвичай не є передбачуваною під час компіляції. Вільний режим дозволяє нам створювати складні динамічні структури просто 
**Перерозподіл пам'яті:**
- Шаблон створення об'єкта невідомий під час компіляції, неможливо передбачити, коли даний об'єкт може стати непотрібним
- Наприклад, у мові C програмісти змушені використовувати malloc() та free() для виділення та звільнення пам'яті
# Проблема доступності
Проблема доступності полягає в тому, що ми можемо легко отримати недосяжну проблему після відокремлення посилання. Проблема керування пам’яттю виникає через непередбачуваність операцій, які впливають на множину досяжних екземплярів: створення та від’єднання. У деяких випадках таке передбачення можливе — для структур даних, керованих у строго контрольований спосіб (наприклад, згадайте зв’язний список у мові C).

Існують три загальні підходи щодо об’єктів, які стають недосяжними.
- Пасивний підхід — ігнорувати проблему й сподіватися, що пам’яті вистачить для розміщення всіх об’єктів, досяжних чи ні (практично непридатний!).
- Ручне звільнення пам’яті — вимагати від розробників включати в кожен застосунок алгоритм, який шукає недосяжні об’єкти, та надавати механізми для звільнення відповідної пам’яті (наприклад, C++ з командою `delete`).
- Автоматичне збирання сміття — включати в середовище розробки (як частину так званої системи виконання, _runtime system_) автоматичні механізми, які виявляють і звільняють пам’ять, зайняту недосяжними об’єктами (наприклад, Java, C#).