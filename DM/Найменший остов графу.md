Алгоритми Крускала, Прима та Пажравого зупиняються після скінченної кількості кроків, і після зупинки T opt є мінімальним охоплюючим деревом графа G.
# Формулювання задачі
ВХІД:
- Зв'язний граф G = (V, H) з вагою по ребрах.
- Вагова функція w : H → R.
ЗАДАЧА:
-З усіх проміжків графа G нам потрібно визначити проміжок $T^{opt}$, який має мінімальну суму ваг усіх його ребер, тобто 
$\sum_{h \in T} w(h) \rightarrow min$
ВИХІД:
Мінімальний проміжок $T^{opt}$ графа G.
# Алгоритм Крускала
## Вхідні дані
- Зв’язний зважений за ребрами граф  $G = (V, H)$
- Функція ваг  $w : H \rightarrow \mathbb{R}$
## Вихідні дані
- Мінімальне остовне дерево $T_{\text{opt}} = (V, H_{\text{opt}})$
## Опис алгоритму
### K0
Побудувати дискретний фактор:
$T = (V, \varnothing)$
Перейти до **K1**
### K1
Впорядкувати ребра графа $G$ у неспадному порядку за вагою:
$L = \{h_1, h_2, \dots, h_m\}, \quad w(h_1) \le w(h_2) \le \dots \le w(h_m)$
Перейти до **K2**
### K2
Вибрати перше ребро $h_i \in L$:
- якщо $h_i$ утворює цикл у $T$, то $L := L \setminus \div {h_i}$
- якщо $h_i$ не утворює цикл, то:
	$H_T := H_T \cup \{h_i\}$
	$T = (V, H_T)$
	$L := L \setminus \{h_i\}$
Перейти до **K3**
### K3
Якщо $|H_T| = |V| - 1$ → **STOP**
Граф $T = (V, H_T)$є мінімальним остовим деревом. Інакше → перейти до **K2**
## Зауваження
Алгоритм Крускала є жадібним алгоритмом для знаходження мінімального остового дерева.
# Алгоритм Прима

## Вхідні дані
- Зв’язний зважений за ребрами граф $G = (V, H)$
- Функція ваг $w : H \rightarrow \mathbb{R}$
- Множина вершин  $V = \{v_1, v_2, \dots, v_n\}$
## Вихідні дані
- Мінімальне остовне дерево  $T_{\text{opt}} = (V, H_{\text{opt}})$
## Опис алгоритму

### K0
Побудувати початкове дерево:
$T = (V_T, H_T), \quad V_T = \{v_1\}, \quad H_T = \varnothing$
Перейти до **K1**
### K1
Якщо $|V_T| = n$ → **STOP**. Граф $T$ є мінімальним остовним деревом.
Інакше → перейти до **K2**
### K2
Для $v_i \in V_T \quad \text{та} \quad v_j \in (V \setminus V_T)$ вибрати ребро $\{v_i, v_j\}$ з мінімальною вагою.

Після цього:
$V_T := V_T \cup \{v_j\}$
$H_T := H_T \cup \{\{v_i, v_j\}\}$

Перейти до **K1**
## Зауваження
Якщо в кроці **K2** існує кілька ребер з однаковою мінімальною вагою, то:
1. спочатку надається перевага ребру з меншим індексом $i$,
2. при рівності — з меншим індексом $j$.
# Метод зворотного видалення (Жадібний алгоритм)
## Вхідні дані
- Зв’язний зважений за ребрами граф $G = (V, H)$
- Функція ваг  $w : H \rightarrow \mathbb{R}$
## Вихідні дані
- Мінімальне остовне дерево  $T_{\text{opt}} = (V, H_{\text{opt}})$
## Опис алгоритму
### K0
Побудувати початковий граф T = (V, H_T), \quad H_T = H$
Перейти до **K1**
### K1
Впорядкувати ребра графа $G$ у **неспадному порядку за спаданням** ваг:
$$
L = \{h_1, h_2, \dots, h_m\}, \quad
w(h_1) \ge w(h_2) \ge \dots \ge w(h_m)
$$
Перейти до **K2**
### K2
Вибрати перше ребро $h_i \in L$:
- якщо граф  $T - \{h_i\}$ є **зв’язним**, то
	  $H_T := H_T \setminus \{h_i\}$
	  $L := L \setminus \{h_i\}$

- якщо граф  $T - \{h_i\}$ є **незв’язним**, то $L := L \setminus \{h_i\}$
Перейти до **K3**
### K3
Якщо $L = \varnothing$ → **STOP**
Граф $T = (V, H_T)$ є мінімальним остовним деревом.
Інакше → перейти до **K2**
## Зауваження
Цей алгоритм є жадібним і працює за принципом **видалення найдорожчих ребер**, які не порушують зв’язність графа.

# Примітки
- Алгоритм Крускала також часто називають голодним алгоритмом. Загалом, це просто евристика.
- Алгоритм Прима був незалежно описаний Ярніком у 1930 році та Примом у 1957 році.
- Найстарішим алгоритмом для мінімального охоплення є алгоритм Борівки 1926 року. Він запропонував його як пропозицію щодо розподілу електричної мережі.
- Алгоритм Борівки працює за припущення, що ваги всіх ребер відрізняються одна від одної.
- Як алгоритми Краскала, так і алгоритми Пажравого мають єдиний оптимум, якщо ваги всіх ребер відрізняються одна від одної. Якщо є неоднозначність у виборі ребер, алгоритми знаходять один з оптимальних проміжків. 
- Алгоритм Прима завжди знаходить лише один оптимальний проміжок. 
- Кількість кроків алгоритму Борівки не перевищує log²n, а загальна складність становить O(m log m). Найшвидші алгоритми для знаходження мінімального проміжку графа базуються на ідеях цього алгоритму. 
- Вищезазначені алгоритми легко модифікуються для вирішення задачі максимізації.