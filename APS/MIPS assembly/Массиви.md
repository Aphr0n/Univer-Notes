• Складена структура даних
• Багато однакових елементів
• Індекс: визначає позицію елемента в масиві
• Розмір: кількість елементів у масиві

# Приклад
• Масив розміром 5 елементів
• Базова адреса = 0x12348000 (позиція першого елемента в масиві, array[0])
• Перший крок при роботі з масивом: зчитати базову адресу масиву
![[Pasted image 20260108011456.png]]

```C
int array[5];
array[0] = array[0] * 2;
array[1] = array[1] * 2;
```

```MIPS
# array base address = $s0
	lui $s0, 0x1234 # 0x1234 in upper half of $S0
	ori $s0, $s0, 0x8000 # 0x8000 in lower half of $s0
	lw $t1, 0($s0) # $t1 = array[0]
	sll $t1, $t1, 1 # $t1 = $t1 * 2
	sw $t1, 0($s0) # array[0] = $t1
	lw $t1, 4($s0) # $t1 = array[1]
	sll $t1, $t1, 1 # $t1 = $t1 * 2
	sw $t1, 4($s0) # array[1] = $t1
```
## Массиви з циклами for
```C
int array[1000];
int i;

for (i=0; i < 1000; i = i + 1)
	array[i] = array[i] * 8;
```

```MIPS
# MIPS kód
# $s0 = array base address, $s1 = i
# initialization code
	lui $s0, 0x23B8 # $s0 = 0x23B80000
	ori $s0, $s0, 0xF000 # $s0 = 0x23B8F000
	addi $s1, $0, 0 # i = 0
	addi $t2, $0, 1000 # $t2 = 1000
loop:
	slt $t0, $s1, $t2 # i < 1000?
	beq $t0, $0, done # if not then done
	sll $t0, $s1, 2 # $t0 = i * 4 (byte offset)
	add $t0, $t0, $s0 # address of array[i]
	lw $t1, 0($t0) # $t1 = array[i]
	sll $t1, $t1, 3 # $t1 = array[i] * 8
	sw $t1, 0($t0) # array[i] = array[i] * 8
	addi $s1, $s1, 1 # i = i + 1
	j loop # repeat
done:
```
